import re
import json
import time
import uuid
from user import user
from typing import Dict, List, Any, Union, Optional
from apscheduler.job import Job
from ast import literal_eval
from jobs import reminder_job
from config import scheduler
from datetime import datetime, timezone
from dateutil import parser

def check_metadata(metadata: dict) -> dict:
    """
    –£—Ç–æ—á–Ω–µ–Ω–∏–µ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª—è–º–∏
      {
        "text": —Ñ–∞–∫—Ç 1 (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ)
        "price": —Å—É–º–º–∞/—Ü–µ–Ω–∞,
        "datetime_create": —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏ (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ)
        "quantity": –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        "number": –Ω–æ–º–µ—Ä –∏–ª–∏ —Ü–∏—Ñ—Ä–∞ –∫–æ—Ç–æ—Ä—É—é –Ω–µ–ª—å–∑—è –æ—Ç–Ω–µ—Å—Ç–∏ –∫ –∏–º–µ—é—â–∏–º—Å—è
        "rating": —Ä–µ–π—Ç–∏–Ω–≥
        "scheduled_datetime":  –µ—Å–ª–∏ –∑–∞–º–µ—Ç–∫–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∞—Ç—å –Ω–∞—á–∞–ª–æ
    }
    Args:
        metadata (dict): —Å–ª–æ–≤–∞—Ä—å —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –æ—Ç –º–æ–¥–µ–ª–∏

    Returns:
        dict: —É—Ç–æ—á–Ω–µ–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å
    """
    list_keys = ["text", "price", "datetime_create", "quantity", "number", "rating",
                 "list_name", "datetime_reminder"]
    out = {}
    for key in list_keys:
        if key in metadata and metadata[key] != "":
            out[key] = metadata[key]
    out["user"] = str(user.id)  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

    return out


# def convert_to_chroma_filter(data: Dict[str, str]) -> Union[Dict[str, Any], None]:
#     """
#     –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç ChromaDB —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º —á–∏—Å–µ–ª.
#
#     :param data: –°–ª–æ–≤–∞—Ä—å, –≥–¥–µ –∫–ª—é—á–∏ ‚Äî –ø–æ–ª—è, –∞ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã (> , < , = , <= , >=).
#     :return: –ö–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –¥–ª—è ChromaDB.
#     """
#     chroma_conditions = []
#
#     operator_mapping = {
#         "=": "$eq",
#         ">": "$gt",
#         "<": "$lt",
#         ">=": "$gte",
#         "<=": "$lte",
#     }
#
#     for key, value in data.items():
#         if not value:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
#             continue
#
#         match = re.match(r"^(>=|<=|>|<|=)?\s*(.+)$", value)
#         if match:
#             operator, real_value = match.groups()
#             if not operator:
#                 operator = "="  # –ï—Å–ª–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, —Å—á–∏—Ç–∞–µ–º –µ–≥–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ–º
#
#             # –ü–æ–ø—ã—Ç–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —á–∏—Å–ª–∞ (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
#             try:
#                 if key != "user":
#                     # id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ—á–Ω—ã–º
#                     real_value = float(real_value) if "." in real_value else int(real_value)
#             except ValueError:
#                 pass  # –û—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É, –µ—Å–ª–∏ –Ω–µ —á–∏—Å–ª–æ
#
#             chroma_conditions.append({key: {operator_mapping[operator]: real_value}})
#
#     # üîπ –£–±–∏—Ä–∞–µ–º "$and", –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ (—á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ ChromaDB)
#     if not chroma_conditions:
#         return None
#     elif len(chroma_conditions) == 1:
#         return chroma_conditions[0]
#     else:
#         return {"$and": chroma_conditions}
#

def extract_json_to_dict(text: str) -> Optional[Union[Dict[str, Any], List[Any]]]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç JSON-—Å–ª–æ–≤–∞—Ä—å –∏–ª–∏ —Å–ø–∏—Å–æ–∫ –∏–∑ —Å—Ç—Ä–æ–∫–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ–≥–æ –∫–∞–∫ –æ–±—ä–µ–∫—Ç Python.
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –Ω–∞—Ö–æ–¥–∏—Ç —Ç–æ—á–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã JSON.

    Args:
        text: –°—Ç—Ä–æ–∫–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è JSON-–¥–∞–Ω–Ω—ã–µ (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ–∫—Ä—É–∂–µ–Ω–∞ –¥—Ä—É–≥–∏–º —Ç–µ–∫—Å—Ç–æ–º)

    Returns:
        Union[Dict[str, Any], List[Any], None]:
        - –†–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –∏–ª–∏ —Å–ø–∏—Å–æ–∫ Python
        - None, –µ—Å–ª–∏ JSON –Ω–µ –Ω–∞–π–¥–µ–Ω/–Ω–µ–≤–∞–ª–∏–¥–µ–Ω

    """
    # –£–ª—É—á—à–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω –¥–ª—è —Å–ª–æ–≤–∞—Ä–µ–π –∏ —Å–ø–∏—Å–∫–æ–≤
    pattern = r'''
        (?P<dict>\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})|  # –°–ª–æ–≤–∞—Ä–∏
        (?P<list>\[(?:[^\[\]]|\[(?:[^\[\]]|\[[^\[\]]*\])*\])*\])  # –°–ø–∏—Å–∫–∏
    '''

    for match in re.finditer(pattern, text, re.VERBOSE):
        json_str = match.group()
        try:
            # –ü—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ JSON (—Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ–¥–∏–Ω–∞—Ä–Ω—ã—Ö –∫–∞–≤—ã—á–µ–∫)
            json_str = json_str.replace("'", '"')  # –ó–∞–º–µ–Ω—è–µ–º –æ–¥–∏–Ω–∞—Ä–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
            return json.loads(json_str)
        except json.JSONDecodeError:
            try:
                # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ eval
                result = literal_eval(json_str)
                if isinstance(result, (dict, list)):
                    return result
            except (ValueError, SyntaxError):
                continue

    return None


def generate_job_id():
    return f"job_{int(time.time() * 1000)}_{uuid.uuid4().hex[:6]}"


def register_job(job_id: str, message: str, job_dict: Dict) -> Job:
    """
    –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –∑–∞–¥–∞–Ω–∏–µ –≤ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–µ APScheduler –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–ª–æ–≤–∞—Ä—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.

    :param job_id: –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–¥–∞–Ω–∏—è.
    :param message: —Å–æ–æ–±—â–µ–Ω–∏–µ
    :param job_dict: –°–ª–æ–≤–∞—Ä—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–¥–∞–Ω–∏—è, –≤–∫–ª—é—á–∞—è –∫–ª—é—á 'trigger' –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç—Ä–∏–≥–≥–µ—Ä–∞.
    :return: –û–±—ä–µ–∫—Ç —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è (Job).
    """
    job_dict = job_dict.copy()  # —á—Ç–æ–±—ã –Ω–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å
    trigger_type = job_dict.pop("trigger")
    job = scheduler.add_job(
        func=reminder_job,
        trigger=trigger_type,
        id=job_id,
        kwargs={"job_id": job_id, "message": message},
        **job_dict
    )
    print(f"–°–æ–∑–¥–∞–Ω–æ –∑–∞–¥–∞–Ω–∏–µ —Å ID: {job.id}")
    return job


def extract_and_parse_json():
    ...
def iso_timestamp_converter(value: Union[str, int]) -> Union[int, str]:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –º–µ–∂–¥—É ISO 8601 –∏ UNIX timestamp –≤ UTC.

    - –ï—Å–ª–∏ –≤—Ö–æ–¥ ‚Äî —Å—Ç—Ä–æ–∫–∞ ISO 8601 (—Å –∏–ª–∏ –±–µ–∑ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞), –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç timestamp (int) UTC.
      –ï—Å–ª–∏ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –Ω–µ —É–∫–∞–∑–∞–Ω, —Å—á–∏—Ç–∞–µ—Ç—Å—è, —á—Ç–æ –≤—Ä–µ–º—è –≤ UTC.
    - –ï—Å–ª–∏ –≤—Ö–æ–¥ ‚Äî timestamp (int), –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç ISO 8601 —Å—Ç—Ä–æ–∫—É –≤ UTC —Å —Å—É—Ñ—Ñ–∏–∫—Å–æ–º 'Z'.

    :param value: str –∏–ª–∏ int
    :return: int –∏–ª–∏ str
    """
    if isinstance(value, str):
        dt = parser.isoparse(value)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        else:
            dt = dt.astimezone(timezone.utc)
        return int(dt.timestamp())

    elif isinstance(value, int):
        dt = datetime.fromtimestamp(value, timezone.utc)
        return dt.isoformat().replace('+00:00', 'Z')


    else:
        raise ValueError("–ê—Ä–≥—É–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π ISO 8601 –∏–ª–∏ —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º (timestamp)")


def transform_filters(filters: list) -> list:
    """
    –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ —É—Å–ª–æ–≤–∏–π, –∑–∞–º–µ–Ω—è—è –Ω–∞–∑–≤–∞–Ω–∏—è –ø–æ–ª–µ–π –ø–æ `field_mapper()`
    –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—è –∑–Ω–∞—á–µ–Ω–∏—è –≤ `timestamp`, –µ—Å–ª–∏ –ø–æ–ª–µ –º–µ–Ω—è–µ—Ç—Å—è.

    Args:
        filters (list): –°–ø–∏—Å–æ–∫ —É—Å–ª–æ–≤–∏–π, –Ω–∞–ø—Ä–∏–º–µ—Ä:
            [
                {"datetime_create": {"$gte": "2025-06-09T00:00:00"}},
                {"datetime_create": {"$lte": "2025-06-09T23:59:59"}}
            ]

    Returns:
        list: –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è —Å –∑–∞–º–µ–Ω—ë–Ω–Ω—ã–º–∏ –ø–æ–ª—è–º–∏ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.
    """
    field_map = {
        "datetime_create": "timestamp_create",
        "datetime_reminder": "timestamp_reminder",
    }

    transformed = []
    for condition in filters:
        field, value = next(iter(condition.items()))
        if field in field_map:
            field = field_map[field]
            key, date = next(iter(value.items()))
            value = {key: iso_timestamp_converter(date)}
        transformed.append({field: value})

    return transformed